#### 汇编语言 - 寄存器

##### 1. debug 指令

1. **A** (assemble) 以汇编指令的格式在内存中写入一条机器指令。
     - ` -A ` 汇编命令，从指定地址开始输入汇编指令，把汇编指令翻译成机器代码相继存放在指定开始的存储器中。
     - ` -A ` 从 CS:IP 处开始汇编。
     - ` -A 10 `，` -A CS:10` 从 CS:10 处开始汇编。
 	2. **D** (dump) 查看内存中的内容。
     - ` -D ` 显示内存单元的内容
     - ` -D DS:10` 显示从指定位置开始内存区的存储单元内容。
     - ` -D CS:100` 显示当前段的内存区。
 	3. **E** (enter) 修改内存中的内容。
 	4. **G** (go) 跳转到指定内存位置。
     - ` -G ` 从当前 CS:IP 的位置执行程序。
     - ` -G = CS:100 ` 从指定位置执行程序。
     - ` -G 100 ` 等效于 ` -G CS:100 `，因为 CS 是默认段地址寄存器。
     - ` -G 200 ` 从当前位置执行，设置 200 为断点。 
5. **I** 显示端口中的内容。
     1. ` -I ` 读取指定端口中的内容。
     2. ` -I 21` 读取、显示 21H 号端口的内容。
6. **O** 向端口写入数据。
     - ` -O` 向指定端口雪茹数据。
     - ` -O 21 00` 向 21H 号端口写入 00H。
7. **P** (proceed) 执行完所有指令。
8. **R** (register) 查看、修改 CPU 寄存器的内容。
      - `R DS` 修改 DS 寄存器中的值。
9. **T** (trace) 执行一条机器指令。
      - ` -T ` 从当前 CS:IP 处执行一条指令。
      - ` -T 3 ` 从当前 CS:IP 起执行 3 条指令。
      - ` -T = CS:10 ` 从 CS:10 起执行 1 条指令。
      - ` -T = 10 ` 等效于 ` -T = CS:10 `，因为 CS 是默认段地址寄存器。
10. **U** (unassemble) 将内存中的机器指令翻译成汇编指令（反汇编）。
         - ` -U ` 反汇编。
         - ` -U CS:100 `从指定位置开始反汇编。
         - ` -U 100 ` 等效于 ` -U CS:100 ` （CS）是默认段地址寄存器。
         - ` -U CS:100 130 ` 对 CS 段地址寄存器 100~130 内存地址进行反汇编。
         - ` -U CS:100 L10 ` 对指定长度进行反汇编。
11. **?** 帮助
         - ` -? ` 
12. **Q** (quit) 退出 debug。

##### 2. 寄存器

1. **通用寄存器**：`AX`、`BX`、`CX`、`DX`

2. **段地址寄存器**：`DS`、`CS`、`SS`、`ES`

3. **变址寄存器**: `SI (Source Index); DI (Destination Index)`;

   它们只能用做 **16** 位寄存器，一般用来存放地址。

   在 8086 CPU 中，只有 bx，si，di，bp 这 4 个寄存器可以用在 **[ ... ]** 中来进行内存单元的寻址

4. **规则** 

   - `IP` 只和 `CS` 一起用。 (`CS:IP`) 指令
   - `SP` 只和 `SS` 用作堆栈寻址。 (`SS:SP`) 栈顶标记
   - `BP` 是 `SP` 的助手。

##### 3. 总结

- 8086 CPU 中，在任意时刻，CPU 将`CS:IP` 所指向的内容全部当做**指令**来执行；

- 8086 CPU 中，在任意时刻，CPU 将`SS:SP` 所指向的内容当做**栈顶标记**；

- **字节型数据**和**字型数据**

  - 字节型数据的 01 排放：	 `01`
  - 字型数据的 01 排放： 		`01 00`	

- `CALL` 指令将下一条指令的 `IP` 保存在栈中，使 `RET` 指令可以从栈中拿回 `IP`；

- **SEGMENT** 段定义语句

  - 段名 **SEGMENT** [定位类型] [组合类型] [‘类别’]

    ; ...

    段名 ENDS

- **ASSUME** 段使用设定语句

  - **ASSUME** 段寄存器名: 段名 [, 段寄存器名: 段名, 段寄存器名: 段名 ..]

    `ASSUME CS: CODE, DS:DATA`

- **ORG 指令**

  - 汇编编译器在汇编的时候使用汇编地址计算器来计算每条指令的偏移地址，而ORG指令就是用于手动修改当前地址的

    ``` ASM
    test segment
    	org 100h
    begin: 	mov ax,1234h
    test ends
    ; mov ax, 1234h 是段内的第一条语句偏移应该是 0，但是由于 ORG 100H 的缘故，实际的偏移地址就变成了 100H
    ```

- **当前地址 $**

  - $ 表示当前指令的第一个字节的地址

    ``` ASM
    org $ + 8	
    ; 表示表示地址计算器从此处开始向后空 8 个字节出来
    
    jmp $ + 6	
    ; 转跳到本条指令之后 6 个字节处，注意计算地址是 JMP 指令的开始位置不是结束位置，所以这 6 个自己包含了 JMP 本身的长度
    
    ARRAY 1，2，$+4 
    ; 这里的 % 表示的是 ARRAY 的地址不是 $ +4 的地址
    ```

- **字母型数据**前面必须加 **0**；如：`B800H` 必须写成 `0B800H`；

- ``` ASM
  mov ax, 10		; == mov ax, 000A = 10
  mov ax, 10H		; == mov ax, 0010 = 16
  ```

- **JMP** 指令可以修改 **IP** 寄存器中的内容，实现无限跳转；

- **DW** (Ddefine Word)

- **[BX + SI]  [BX + DI]**   

- **WORD PTR** 字型数据

- **BYTE PTR**   字节型数据

- **DIV** 除法指令

  ``` ASM
  ; 8 位除法
  被除数：AX
  除数：  BL
  余数：  AH
  商:	  AL
  mov ax, 16
  mov bl, 3
  div bl
  ; AL = 05, AH = 01
  
  ; 16 位除法；如果除数为 16 位，被除数为 32 位，DX 存放高 16 位，AX 存放低 16 位
  ; AX 保存商，DX 保存余数
  
  ```

- **jmp** 跳转范围

  ``` ASM
  ; 8 位位移  -128 ~ 127
  jmp short [标号]
  ; 16 位位移 -32768 ~ 32767
  jmp near ptr [标号]
  
  mov ax, 2233H
  jmp ax					; 此时 IP 寄存器为：2233H
  
  jmp word ptr ds:[0]		; IP = ds:[0] 的字型数据
  jmp dword ptr ds:[0]	; IP = ds:[0] 的字型数据，CS = ds:[2] 的字型数据 
  ```

- **jcxz** 条件转移指令

  ``` ASM
  j  = jmp
  cx = cx 寄存器
  z  = zero
  cx != 0 时候进行跳转
  所有条件转移指令都是短转移 (-128 ~ 127)
  经过编译后，机器码包含了跳转范围：EBXX
  计算方式：标号处的偏移地址 - jmp 指令后第一个字节的地址
  ```

- **DW OFFSET start**

- **RET** & **RETF**

  ``` ASM
  ret 相当于执行 pop ip
  retf 相当于执行 pop ip, pop cs
  ```

- **CALL**

  ``` ASM
  push ip
  jmp near ptr [标号]
  位移 = 标号处的偏移地址 - call 指令后第一个字节的地址
  范围：-32768 ~ 32767
  ;; ==========================================
  ;; call 与 ret 配合使用
  	call A		; 将下一条指令的 IP push 保存起来
  	push ax, 0
  
  A:
  	nop
  	ret			; 将 IP pop 出来
  ;; ==========================================	
  ```

- **MUL** 乘法指令

  ``` ASM
  ; 两个数相乘，要么都是 8 位的，要么都是 16 位的
  ; 8 位乘法
  一个数字默认存放在 al 中，另一个放在其他 8 位寄存器中，或者字节型内存单元中
  mov al, 8
  mov bl, 16
  mul bl
  
  mul byte ptr ds:[0]
  
  ; 16 位乘法
  一个数字默认存放在 ax 中，另一个放在其他 16 位寄存器中，或者字型内存单元中
  若得到一个 32 位数值，低 16 位存放在 ax，高 16 位存放在 dx
  mov ax, FFFH
  mov bx, 2
  mul bx
  
  mul word ptr ds:[1]
  ```

- **CF** 标志位 寄存器 [ Carry Flag ] 进位标志

  CY = Carry Yes

  NC = Not	 Carry 

  与计算相关（进位）														MOV 指令不影响标志位

- **ZF** 标志位寄存器 [ Zero Flag ] 

  ZR = Zero

  NZ = Not Zero

- **PF** Parity Flag 奇偶性

  PE = Parity Even	偶数	0000 0011B		0000 1111B		0000 0000B

  PO = Parity Odd 	奇数	0000 0001B		0000 1011B

- **SF** 符号标志位 [ Sign Flag ]      把计算的结果看作是正数还是负数      MUL 不影响 SF 标志位

  NG = Negative	负数

  PL = Positive	   正数

- **OF** [ Overflow Flag ] 溢出标志位               在运算过程中决定

  OV 溢出

  NV 没有溢出

- **ADC** [ Add Carry ]

  ``` ASM 
  add ax, bx 	; ax = ax + bx
  adc ax, bx	; ax = ax + bx + carry
  ```

- **SBB** [ Sub Carry ]

  ``` ASM
  sub ax, bx 	; ax = ax - bx
  sbb ax, bx 	; ax = ax - bx - carry
  ```
